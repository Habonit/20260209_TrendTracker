{
  "meta": {
    "title": "파이썬 던전 탈출",
    "version": "1.0.0",
    "description": "TrendTracker에서 배운 파이썬 개념을 복습하는 터미널 TRPG 퀴즈 게임"
  },

  "intro": {
    "welcome": [
      "",
      "╔══════════════════════════════════════════════════════╗",
      "║                                                      ║",
      "║          🐍 파이썬 던전에 오신 것을 환영합니다 🐍          ║",
      "║                                                      ║",
      "╚══════════════════════════════════════════════════════╝",
      ""
    ],
    "story": [
      "당신은 파이썬 마법을 배우는 견습 마법사입니다.",
      "전설의 'TrendTracker 던전'에는 7명의 문지기가 있습니다.",
      "각 문지기의 시험을 통과해야만 다음 관문으로 나아갈 수 있습니다.",
      "",
      "모든 관문을 통과하면... 당신은 진정한 파이썬 마법사가 됩니다!",
      "",
      "⚠️  주의: 각 관문에서 2번 틀리면 처음부터 다시 도전해야 합니다.",
      ""
    ],
    "name_prompt": "모험자의 이름을 입력하세요: ",
    "name_empty_error": "이름을 입력해주세요.",
    "name_confirmed": "환영합니다, {name}님! 당신의 여정이 시작됩니다."
  },

  "menu": {
    "header": [
      "",
      "╔══════════════════════════════════════════════════════╗",
      "║                    📜 관문 선택                       ║",
      "╚══════════════════════════════════════════════════════╝"
    ],
    "phase_format": "  {num}. Phase {num}: {title} - {status}",
    "exit_option": "  0. 게임 종료",
    "status_cleared": "✅ 클리어",
    "status_available": "🔓 도전 가능",
    "status_locked": "🔒 잠김",
    "prompt": "도전할 관문을 선택하세요: ",
    "invalid_input": "올바른 숫자를 입력해주세요.",
    "already_cleared": "이미 클리어한 관문입니다.",
    "phase_locked": "아직 도전할 수 없습니다. Phase {phase}부터 도전하세요.",
    "divider": "════════════════════════════════════════════════════════"
  },

  "quiz": {
    "header": [
      "",
      "══════════════════════════════════════════════════════",
      "  문제 {current}/10  |  목숨: {lives}",
      "══════════════════════════════════════════════════════"
    ],
    "question_format": "\nQ{num}. {question}",
    "choice_divider": "────────────────────────────────────────",
    "choice_format": "  {num}) {choice}",
    "prompt": "\n정답을 선택하세요 (1-5): ",
    "invalid_range": "1~5 사이의 숫자를 입력하세요.",
    "invalid_number": "숫자를 입력해주세요.",
    "correct": "\n✅ 정답입니다!",
    "wrong": "\n❌ 오답입니다! 정답은 {answer}번입니다.",
    "explanation": "\n📖 해설: {explanation}",
    "continue_prompt": "\n[Enter를 눌러 계속]",
    "life_lost": "💔 목숨을 1개 잃었습니다...",
    "lives_display": {
      "2": "❤️ ❤️",
      "1": "❤️ 🖤",
      "0": "🖤 🖤"
    }
  },

  "result": {
    "header": [
      "",
      "══════════════════════════════════════════════════════",
      "                    📊 시험 결과                        ",
      "══════════════════════════════════════════════════════"
    ],
    "score": "정답: {correct}/10",
    "pass_requirement": "(8문제 이상 정답 시 통과)",
    "passed": "🎉 축하합니다! 시험에 통과했습니다!",
    "failed_score": "😢 8문제 이상 맞춰야 통과입니다. (현재: {correct}/10)"
  },

  "game_over": {
    "header": [
      "",
      "╔══════════════════════════════════════════════════════╗",
      "║                    💀 GAME OVER                      ║",
      "╚══════════════════════════════════════════════════════╝"
    ],
    "message": "목숨을 모두 잃었습니다...",
    "retry_hint": "다시 공부하고 도전해보세요!",
    "exit_message": "게임을 종료합니다."
  },

  "certificate": {
    "saved": "\n📜 인증서가 저장되었습니다: {filename}",
    "phase_template": [
      "══════════════════════════════════════════════════════",
      "         🎉 {guardian}의 인증서 🎉",
      "══════════════════════════════════════════════════════",
      "",
      "축하합니다, {name}님!",
      "",
      "Phase {phase} 시험을 통과하셨습니다.",
      "{custom_message}",
      "",
      "통과 일시: {datetime}",
      "",
      "- {guardian} -",
      "══════════════════════════════════════════════════════"
    ],
    "master_template": [
      "╔════════════════════════════════════════════════════════════╗",
      "║                                                            ║",
      "║              🏆 파이썬 마법사 인증서 🏆                      ║",
      "║                                                            ║",
      "╠════════════════════════════════════════════════════════════╣",
      "║                                                            ║",
      "║     이 인증서는                                             ║",
      "║                                                            ║",
      "║                    {name}                                  ║",
      "║                                                            ║",
      "║     님이 파이썬 던전의 모든 관문을 통과하고                   ║",
      "║     진정한 파이썬 마법사가 되었음을 증명합니다.                ║",
      "║                                                            ║",
      "╠════════════════════════════════════════════════════════════╣",
      "║                                                            ║",
      "║     ✅ Phase 1: 환경 설정         - 통과                    ║",
      "║     ✅ Phase 2: 클래스와 타입      - 통과                    ║",
      "║     ✅ Phase 3: API와 예외처리     - 통과                    ║",
      "║     ✅ Phase 4: 파일과 데이터      - 통과                    ║",
      "║     ✅ Phase 5: Streamlit UI     - 통과                    ║",
      "║     ✅ Phase 6: 앱 구조           - 통과                    ║",
      "║     ✅ Phase 7: 에러 핸들링        - 통과                    ║",
      "║                                                            ║",
      "╠════════════════════════════════════════════════════════════╣",
      "║                                                            ║",
      "║     발급일: {datetime}                                      ║",
      "║                                                            ║",
      "║           \"코드의 힘이 당신과 함께하길\"                      ║",
      "║                                                            ║",
      "║              - TrendTracker 던전 마스터 -                   ║",
      "║                                                            ║",
      "╚════════════════════════════════════════════════════════════╝"
    ]
  },

  "exit": {
    "message": "\n게임을 종료합니다. 다음에 또 도전하세요!",
    "goodbye": "안녕히 가세요, {name}님!"
  },

  "final_ending": {
    "header": [
      "",
      "╔════════════════════════════════════════════════════════════╗",
      "║                                                            ║",
      "║           🎊 축하합니다! 모든 관문을 통과했습니다! 🎊          ║",
      "║                                                            ║",
      "╚════════════════════════════════════════════════════════════╝"
    ],
    "message": [
      "",
      "{name}님, 당신은 진정한 파이썬 마법사입니다!",
      "",
      "7개의 관문을 모두 통과한 당신에게",
      "TrendTracker 던전 마스터의 축복을 드립니다.",
      "",
      "당신이 배운 것들:",
      "  ✅ 환경 설정과 패키지 관리",
      "  ✅ 클래스와 데이터 모델링",
      "  ✅ API 통신과 예외 처리",
      "  ✅ 파일 입출력과 데이터 관리",
      "  ✅ Streamlit UI 개발",
      "  ✅ 앱 구조 설계",
      "  ✅ 에러 핸들링과 UX",
      "",
      "이제 당신만의 프로젝트를 시작할 준비가 되었습니다!",
      "",
      "🏆 최종 인증서가 발급되었습니다: python_master_certificate.txt",
      ""
    ]
  },

  "phases": {
    "1": {
      "title": "환경 설정",
      "guardian": {
        "name": "설정술사 엔브",
        "greeting": [
          "",
          "흠... 또 한 명의 도전자가 왔군.",
          "",
          "나는 설정술사 엔브.",
          "이 던전의 첫 번째 관문을 지키고 있지.",
          "",
          "환경 설정은 모든 마법의 기초야.",
          "패키지 관리자, 가상환경, 환경변수...",
          "이것들을 모르면 한 발자국도 나아갈 수 없어.",
          "",
          "자, 네 기초가 얼마나 탄탄한지 보여줘.",
          "단, 2번 틀리면 끝이야. 환경 설정에는 실수가 허용되지 않으니까.",
          "",
          "준비됐나?"
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "...인정하지.",
          "",
          "{name}, 네 기초는 확실해.",
          "환경 설정의 중요성을 알고 있구나.",
          "",
          "이 인증서를 가져가.",
          "다음 관문에서 행운을 빈다."
        ],
        "failure": [
          "",
          "...역시 그렇군.",
          "",
          "{name}, 기초가 부족해.",
          "환경 설정을 제대로 못 하면 어떤 코드도 제대로 돌아가지 않아.",
          "",
          "돌아가서 다시 공부하고 와.",
          "나는 여기서 기다리고 있을 테니까."
        ],
        "certificate_message": "환경 설정의 기초를 완벽히 이해한 증거입니다."
      },
      "questions": [
        {
          "question": "패키지 관리자의 역할로 적절하지 않은 것은?",
          "choices": [
            "라이브러리 설치",
            "의존성 관리",
            "버전 충돌 해결",
            "코드 문법 검사",
            "패키지 삭제"
          ],
          "answer": 4,
          "explanation": "패키지 관리자는 라이브러리 설치/삭제, 의존성 관리, 버전 관리를 담당합니다. 코드 문법 검사는 린터(linter)의 역할입니다."
        },
        {
          "question": "uv가 pip보다 빠른 주된 이유는?",
          "choices": [
            "Python으로 작성되어서",
            "Rust로 작성되어서",
            "JavaScript로 작성되어서",
            "C++로 작성되어서",
            "Go로 작성되어서"
          ],
          "answer": 2,
          "explanation": "uv는 Rust로 작성되어 pip보다 10~100배 빠른 속도를 제공합니다. Rust는 메모리 안전성과 높은 성능을 제공하는 시스템 프로그래밍 언어입니다."
        },
        {
          "question": "가상환경을 사용하는 가장 주된 이유는?",
          "choices": [
            "코드 실행 속도를 높이기 위해",
            "프로젝트별 의존성을 분리하기 위해",
            "인터넷 연결 없이 작업하기 위해",
            "파이썬 버전을 자동 업데이트하기 위해",
            "보안을 강화하기 위해"
          ],
          "answer": 2,
          "explanation": "가상환경은 프로젝트마다 독립된 패키지 환경을 제공합니다. A 프로젝트에서 pandas 1.0을, B 프로젝트에서 pandas 2.0을 동시에 사용할 수 있습니다."
        },
        {
          "question": ".env 파일에 저장하기 적절하지 않은 것은?",
          "choices": [
            "API 키",
            "데이터베이스 비밀번호",
            "HTML 템플릿 코드",
            "비밀 토큰",
            "서버 URL"
          ],
          "answer": 3,
          "explanation": ".env 파일은 환경변수(비밀 정보, 설정값)를 저장하는 곳입니다. HTML 템플릿 같은 코드는 별도의 파일로 관리해야 합니다."
        },
        {
          "question": "os.getenv('API_KEY', 'default')에서 'default'의 역할은?",
          "choices": [
            "API_KEY가 있을 때 반환되는 값",
            "API_KEY가 없을 때 반환되는 기본값",
            "에러 메시지",
            "환경변수 이름",
            "파일 경로"
          ],
          "answer": 2,
          "explanation": "os.getenv()의 두 번째 인자는 해당 환경변수가 없을 때 반환할 기본값입니다. 환경변수가 설정되지 않았을 때 None 대신 지정한 값이 반환됩니다."
        },
        {
          "question": "load_dotenv() 함수의 역할은?",
          "choices": [
            ".env 파일을 삭제한다",
            ".env 파일의 내용을 환경변수로 로드한다",
            "환경변수를 .env 파일에 저장한다",
            "환경변수를 암호화한다",
            ".env 파일을 생성한다"
          ],
          "answer": 2,
          "explanation": "load_dotenv()는 .env 파일을 읽어서 그 안의 KEY=VALUE 쌍을 운영체제의 환경변수로 등록합니다."
        },
        {
          "question": "레이어드 아키텍처에서 services 폴더의 역할은?",
          "choices": [
            "데이터 저장소 관리",
            "UI 화면 구성",
            "외부 API와의 통신",
            "환경 설정 관리",
            "데이터 모델 정의"
          ],
          "answer": 3,
          "explanation": "services 폴더는 외부 API와의 통신을 담당합니다. Tavily API 호출, Gemini API 호출 등의 로직이 여기에 위치합니다."
        },
        {
          "question": "uv sync 명령어의 역할은?",
          "choices": [
            "새 프로젝트를 생성한다",
            "uv.lock 파일 기준으로 패키지를 동기화한다",
            "가상환경을 삭제한다",
            "패키지를 업로드한다",
            "Python 버전을 변경한다"
          ],
          "answer": 2,
          "explanation": "uv sync는 uv.lock 파일에 명시된 정확한 버전의 패키지들을 설치합니다. 이를 통해 팀원들이 동일한 환경을 구성할 수 있습니다."
        },
        {
          "question": ".gitignore에 .env를 추가하는 이유는?",
          "choices": [
            "파일 크기를 줄이기 위해",
            "API 키 등 민감 정보가 Git에 올라가는 것을 방지하기 위해",
            ".env 파일이 자동으로 생성되게 하기 위해",
            "환경변수 로딩 속도를 높이기 위해",
            ".env 파일을 암호화하기 위해"
          ],
          "answer": 2,
          "explanation": ".env 파일에는 API 키, 비밀번호 등 민감한 정보가 담겨 있습니다. .gitignore에 추가하여 실수로 Git에 커밋되는 것을 방지합니다."
        },
        {
          "question": "repositories 폴더의 역할로 가장 적절한 것은?",
          "choices": [
            "API 호출 로직",
            "데이터 저장 및 조회",
            "UI 컴포넌트",
            "환경 설정",
            "에러 처리"
          ],
          "answer": 2,
          "explanation": "repositories 폴더는 데이터 저장소(CSV, 데이터베이스 등)와의 상호작용을 담당합니다. 데이터 저장, 조회, 삭제 등의 CRUD 연산이 여기에 위치합니다."
        }
      ]
    },

    "2": {
      "title": "클래스와 타입",
      "guardian": {
        "name": "도메인 현자 클래스",
        "greeting": [
          "",
          "오... 첫 번째 관문을 통과했군.",
          "",
          "나는 도메인 현자 클래스.",
          "데이터의 본질을 꿰뚫어 보는 자이지.",
          "",
          "클래스란 무엇인가?",
          "그것은 세상의 모든 것을 담는 그릇이다.",
          "@dataclass는 그 그릇을 더욱 정교하게 만들어주지.",
          "",
          "타입 힌트는... 미래의 나에게 보내는 편지야.",
          "\"이 변수에는 이런 것이 들어온다\"라고 말해주는 것이지.",
          "",
          "자, 네가 데이터의 본질을 이해하고 있는지...",
          "지금부터 확인해보겠다."
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "훌륭하다, {name}.",
          "",
          "데이터의 형상을 빚어내는 기술...",
          "너는 그것을 충분히 이해하고 있구나.",
          "",
          "@dataclass의 힘을 알고,",
          "타입 힌트의 가치를 아는 자...",
          "",
          "다음 관문으로 나아가거라.",
          "네 여정에 축복이 함께하길."
        ],
        "failure": [
          "",
          "아쉽구나, {name}.",
          "",
          "데이터의 본질을 이해하지 못한 채",
          "앞으로 나아가려 했구나.",
          "",
          "클래스와 타입 힌트를 다시 공부하거라.",
          "그것이 모든 프로그래밍의 기반이 되니까."
        ],
        "certificate_message": "@dataclass와 타입 힌트의 힘을 이해한 증거입니다."
      },
      "questions": [
        {
          "question": "클래스에서 __init__ 메서드의 역할은?",
          "choices": [
            "클래스를 삭제할 때 호출된다",
            "인스턴스가 생성될 때 초기화를 담당한다",
            "클래스의 모든 메서드를 나열한다",
            "상속을 처리한다",
            "클래스를 문자열로 변환한다"
          ],
          "answer": 2,
          "explanation": "__init__은 생성자(constructor)로, 인스턴스가 생성될 때 자동으로 호출되어 초기 속성을 설정합니다."
        },
        {
          "question": "@dataclass 데코레이터가 자동으로 생성하지 않는 것은?",
          "choices": [
            "__init__ 메서드",
            "__repr__ 메서드",
            "__eq__ 메서드",
            "__add__ 메서드",
            "속성 정의"
          ],
          "answer": 4,
          "explanation": "@dataclass는 __init__, __repr__, __eq__ 등을 자동 생성하지만, __add__ 같은 연산자 오버로딩은 직접 구현해야 합니다."
        },
        {
          "question": "타입 힌트 List[str]의 의미는?",
          "choices": [
            "문자열 하나",
            "문자열로 구성된 리스트",
            "리스트 하나를 문자열로 변환",
            "문자열 또는 리스트",
            "리스트의 길이"
          ],
          "answer": 2,
          "explanation": "List[str]은 문자열(str)을 원소로 가지는 리스트를 의미합니다. 예: ['apple', 'banana', 'cherry']"
        },
        {
          "question": "Optional[str]이 의미하는 것은?",
          "choices": [
            "반드시 문자열이어야 함",
            "문자열 또는 None일 수 있음",
            "문자열의 길이가 선택적임",
            "여러 개의 문자열",
            "문자열을 숫자로 변환"
          ],
          "answer": 2,
          "explanation": "Optional[str]은 str 또는 None일 수 있음을 나타냅니다. 값이 있을 수도 있고 없을 수도 있는 경우에 사용합니다."
        },
        {
          "question": "self 키워드의 역할은?",
          "choices": [
            "클래스 자체를 가리킨다",
            "인스턴스 자기 자신을 가리킨다",
            "부모 클래스를 가리킨다",
            "전역 변수를 가리킨다",
            "다른 클래스를 가리킨다"
          ],
          "answer": 2,
          "explanation": "self는 메서드를 호출한 인스턴스 자기 자신을 가리킵니다. self.name = 'Tom'은 해당 인스턴스의 name 속성을 설정합니다."
        },
        {
          "question": "@dataclass에서 기본값이 있는 속성의 위치로 올바른 것은?",
          "choices": [
            "반드시 맨 앞에 와야 한다",
            "반드시 기본값 없는 속성 뒤에 와야 한다",
            "순서는 상관없다",
            "반드시 맨 가운데 와야 한다",
            "기본값 있는 속성은 사용할 수 없다"
          ],
          "answer": 2,
          "explanation": "@dataclass에서 기본값이 있는 속성은 반드시 기본값이 없는 속성 뒤에 위치해야 합니다. 그렇지 않으면 SyntaxError가 발생합니다."
        },
        {
          "question": "도메인 모델(Domain Model)의 주된 목적은?",
          "choices": [
            "UI 화면을 구성한다",
            "프로그램이 다루는 핵심 개념을 코드로 표현한다",
            "데이터베이스를 생성한다",
            "API를 호출한다",
            "로그를 기록한다"
          ],
          "answer": 2,
          "explanation": "도메인 모델은 프로그램이 다루는 핵심 개념(예: 뉴스 기사, 검색 결과)을 클래스로 정의하여 코드에서 일관되게 사용할 수 있게 합니다."
        },
        {
          "question": "다음 중 올바른 타입 힌트 문법은?",
          "choices": [
            "def func(x) -> str int:",
            "def func(x: str) -> int:",
            "def func(x: str -> int):",
            "def func(x): str -> int",
            "def func[str](x) -> int:"
          ],
          "answer": 2,
          "explanation": "함수의 타입 힌트는 'def 함수명(인자: 타입) -> 반환타입:' 형식입니다. 인자 뒤에 콜론(:), 함수 뒤에 화살표(->)를 사용합니다."
        },
        {
          "question": "인스턴스와 클래스의 관계를 가장 잘 설명한 것은?",
          "choices": [
            "클래스는 인스턴스의 복사본이다",
            "인스턴스는 클래스라는 설계도로 만든 실체이다",
            "클래스와 인스턴스는 같은 것이다",
            "인스턴스는 클래스보다 먼저 정의된다",
            "하나의 클래스에서는 하나의 인스턴스만 만들 수 있다"
          ],
          "answer": 2,
          "explanation": "클래스는 설계도(붕어빵 틀)이고, 인스턴스는 그 설계도로 만든 실제 객체(붕어빵)입니다. 하나의 클래스로 여러 인스턴스를 만들 수 있습니다."
        },
        {
          "question": "Dict[str, int]가 의미하는 것은?",
          "choices": [
            "문자열과 정수의 리스트",
            "키가 문자열이고 값이 정수인 딕셔너리",
            "문자열 또는 정수",
            "키가 정수이고 값이 문자열인 딕셔너리",
            "문자열을 정수로 변환하는 함수"
          ],
          "answer": 2,
          "explanation": "Dict[str, int]는 키(key)가 문자열이고 값(value)이 정수인 딕셔너리를 의미합니다. 예: {'apple': 3, 'banana': 5}"
        }
      ]
    },

    "3": {
      "title": "API와 예외처리",
      "guardian": {
        "name": "API 수호자 리퀘스트",
        "greeting": [
          "",
          "야호~! 새로운 도전자다!",
          "",
          "안녕안녕! 나는 API 수호자 리퀘스트야!",
          "외부 세계와의 통신을 담당하고 있지!",
          "",
          "너 혹시 API가 뭔지 알아?",
          "HTTP는? 상태 코드는?",
          "try-except로 예외 처리하는 법은?!",
          "",
          "아 너무 설레! 오랜만에 도전자가 와서!",
          "근데 있지, 나도 일은 일이니까...",
          "2번 틀리면 돌려보내야 해. 미안~",
          "",
          "자자, 시작해볼까?!"
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "우와아아~! {name}, 통과야!!!",
          "",
          "대박대박! API 완전 잘 알고 있네!",
          "HTTP도 알고, 예외 처리도 완벽하고!",
          "",
          "이제 너도 외부 세계랑 자유롭게 소통할 수 있어!",
          "Tavily든 Gemini든 뭐든 가져와~!",
          "",
          "다음 관문 파이팅! 화이팅!"
        ],
        "failure": [
          "",
          "앗... {name}, 아쉽다...",
          "",
          "음... API 쪽이 좀 약한 것 같아.",
          "근데 괜찮아! 다시 공부하고 오면 돼!",
          "",
          "try-except 특히 중요하니까 잘 봐!",
          "다음엔 꼭 통과할 수 있을 거야!"
        ],
        "certificate_message": "외부 세계와 자유롭게 소통할 수 있는 자격을 얻었습니다!"
      },
      "questions": [
        {
          "question": "API를 식당에 비유할 때, 웨이터에 해당하는 것은?",
          "choices": [
            "요리사",
            "손님",
            "API 자체",
            "식재료",
            "영수증"
          ],
          "answer": 3,
          "explanation": "API는 손님(클라이언트)의 주문(요청)을 받아 주방(서버)에 전달하고, 음식(응답)을 가져다주는 웨이터 역할을 합니다."
        },
        {
          "question": "HTTP 상태 코드 401이 의미하는 것은?",
          "choices": [
            "성공",
            "잘못된 요청",
            "인증 실패",
            "서버 오류",
            "리다이렉트"
          ],
          "answer": 3,
          "explanation": "401 Unauthorized는 인증에 실패했음을 의미합니다. 주로 API 키가 잘못되었거나 만료되었을 때 발생합니다."
        },
        {
          "question": "try-except 구문에서 except 블록이 실행되는 시점은?",
          "choices": [
            "try 블록이 성공적으로 완료되었을 때",
            "try 블록에서 예외가 발생했을 때",
            "프로그램이 시작될 때",
            "함수가 종료될 때",
            "항상 실행된다"
          ],
          "answer": 2,
          "explanation": "except 블록은 try 블록 안에서 예외(에러)가 발생했을 때만 실행됩니다. 예외가 발생하지 않으면 except 블록은 건너뜁니다."
        },
        {
          "question": "raise 키워드의 역할은?",
          "choices": [
            "예외를 잡는다",
            "예외를 발생시킨다",
            "예외를 무시한다",
            "예외를 출력한다",
            "예외를 삭제한다"
          ],
          "answer": 2,
          "explanation": "raise는 예외를 의도적으로 발생시키는 키워드입니다. 예: raise ValueError('잘못된 값입니다')"
        },
        {
          "question": "HTTP 상태 코드 200이 의미하는 것은?",
          "choices": [
            "요청 성공",
            "클라이언트 오류",
            "서버 오류",
            "리다이렉트",
            "인증 필요"
          ],
          "answer": 1,
          "explanation": "200 OK는 요청이 성공적으로 처리되었음을 의미합니다. API 호출이 정상적으로 완료되었을 때 반환됩니다."
        },
        {
          "question": "커스텀 예외 클래스를 만들 때 상속받아야 하는 클래스는?",
          "choices": [
            "Object",
            "Exception",
            "Error",
            "BaseClass",
            "Custom"
          ],
          "answer": 2,
          "explanation": "파이썬에서 커스텀 예외는 Exception 클래스를 상속받아 만듭니다. 예: class MyError(Exception): pass"
        },
        {
          "question": "finally 블록의 특징은?",
          "choices": [
            "예외가 발생해야만 실행된다",
            "예외가 발생하지 않아야만 실행된다",
            "예외 발생 여부와 관계없이 항상 실행된다",
            "try 블록보다 먼저 실행된다",
            "한 번만 정의할 수 있다"
          ],
          "answer": 3,
          "explanation": "finally 블록은 예외 발생 여부와 관계없이 항상 실행됩니다. 주로 파일 닫기, 연결 종료 등 정리 작업에 사용됩니다."
        },
        {
          "question": "HTTP 상태 코드 429가 의미하는 것은?",
          "choices": [
            "인증 실패",
            "페이지를 찾을 수 없음",
            "요청이 너무 많음 (Rate Limit)",
            "서버 내부 오류",
            "요청 성공"
          ],
          "answer": 3,
          "explanation": "429 Too Many Requests는 일정 시간 내에 너무 많은 요청을 보냈을 때 발생합니다. 잠시 기다린 후 다시 시도해야 합니다."
        },
        {
          "question": "서비스 레이어(Service Layer)의 주된 역할은?",
          "choices": [
            "데이터를 화면에 표시한다",
            "데이터를 파일에 저장한다",
            "외부 API 호출과 비즈니스 로직을 처리한다",
            "환경 변수를 로드한다",
            "로그를 기록한다"
          ],
          "answer": 3,
          "explanation": "서비스 레이어는 외부 API 호출과 비즈니스 로직을 담당합니다. UI와 데이터 저장소 사이에서 중간 다리 역할을 합니다."
        },
        {
          "question": "다음 중 except Exception as e에서 e의 역할은?",
          "choices": [
            "예외를 무시한다",
            "예외 객체를 변수에 저장하여 정보를 얻을 수 있게 한다",
            "예외를 다시 발생시킨다",
            "예외 타입을 변경한다",
            "예외를 출력한다"
          ],
          "answer": 2,
          "explanation": "as e는 발생한 예외 객체를 e 변수에 저장합니다. 이를 통해 예외 메시지나 타입 등의 정보를 얻을 수 있습니다."
        }
      ]
    },

    "4": {
      "title": "파일과 데이터",
      "guardian": {
        "name": "창고지기 레포",
        "greeting": [
          "",
          "...왔군.",
          "",
          "나는 레포. 데이터 창고를 지키고 있어.",
          "",
          "파일 입출력... CSV... pandas...",
          "데이터를 저장하고, 읽고, 관리하는 것.",
          "그게 내 영역이야.",
          "",
          "Repository 패턴을 알면...",
          "데이터를 다루는 게 훨씬 깔끔해져.",
          "",
          "...질문에 답해봐.",
          "2번 틀리면 돌아가야 해.",
          "...미안하지만, 규칙이야."
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "...잘했어, {name}.",
          "",
          "데이터를 소중히 다루는 법을 알고 있군.",
          "with문도 알고, pandas도 알고...",
          "",
          "...이 인증서.",
          "네가 데이터 창고를 통과한 증거야.",
          "",
          "...다음 관문에서도 잘해."
        ],
        "failure": [
          "",
          "...아쉽군, {name}.",
          "",
          "데이터를 다루는 건 신중해야 해.",
          "실수하면 데이터가 날아가니까...",
          "",
          "...다시 공부하고 와.",
          "파일 입출력, 특히 with문 잘 봐."
        ],
        "certificate_message": "데이터를 소중히 다루는 법을 익힌 증거입니다."
      },
      "questions": [
        {
          "question": "with open('file.txt', 'w') as f:에서 'w'의 의미는?",
          "choices": [
            "읽기 모드",
            "쓰기 모드 (덮어쓰기)",
            "추가 모드",
            "바이너리 모드",
            "실행 모드"
          ],
          "answer": 2,
          "explanation": "'w'는 쓰기(write) 모드로, 파일이 이미 있으면 내용을 덮어씁니다. 새로 파일을 만들거나 기존 내용을 완전히 교체할 때 사용합니다."
        },
        {
          "question": "with 문을 사용하는 가장 큰 장점은?",
          "choices": [
            "코드가 더 빠르게 실행된다",
            "파일을 자동으로 닫아준다",
            "파일 크기가 줄어든다",
            "암호화가 된다",
            "파일을 압축한다"
          ],
          "answer": 2,
          "explanation": "with 문을 사용하면 블록이 끝날 때 자동으로 파일이 닫힙니다. close()를 깜빡해도 리소스 누수가 발생하지 않습니다."
        },
        {
          "question": "CSV 파일의 특징으로 올바른 것은?",
          "choices": [
            "데이터가 암호화되어 저장된다",
            "쉼표로 값들이 구분된다",
            "이미지를 저장할 수 있다",
            "압축된 형태로 저장된다",
            "실행 가능한 코드가 포함된다"
          ],
          "answer": 2,
          "explanation": "CSV는 Comma Separated Values의 약자로, 값들이 쉼표(,)로 구분된 텍스트 파일입니다."
        },
        {
          "question": "pd.read_csv('data.csv')의 반환 타입은?",
          "choices": [
            "list",
            "dict",
            "DataFrame",
            "str",
            "tuple"
          ],
          "answer": 3,
          "explanation": "pd.read_csv()는 CSV 파일을 읽어 pandas DataFrame 객체로 반환합니다. DataFrame은 행과 열로 구성된 2차원 표 형태입니다."
        },
        {
          "question": "df.to_csv('output.csv', index=False)에서 index=False의 역할은?",
          "choices": [
            "파일을 압축한다",
            "행 번호(인덱스)를 파일에 저장하지 않는다",
            "컬럼 이름을 저장하지 않는다",
            "파일을 암호화한다",
            "빈 값을 제거한다"
          ],
          "answer": 2,
          "explanation": "index=False를 지정하면 DataFrame의 인덱스(행 번호)가 CSV 파일에 저장되지 않습니다. 불필요한 열이 추가되는 것을 방지합니다."
        },
        {
          "question": "os.path.exists('file.txt')가 반환하는 값은?",
          "choices": [
            "파일 내용",
            "파일 크기",
            "True 또는 False",
            "파일 경로",
            "파일 생성 시간"
          ],
          "answer": 3,
          "explanation": "os.path.exists()는 파일이나 폴더가 존재하면 True, 존재하지 않으면 False를 반환합니다."
        },
        {
          "question": "Repository 패턴의 주된 목적은?",
          "choices": [
            "코드 실행 속도를 높인다",
            "데이터 저장 방식을 추상화하여 일관된 인터페이스를 제공한다",
            "메모리 사용량을 줄인다",
            "네트워크 통신을 담당한다",
            "사용자 인터페이스를 만든다"
          ],
          "answer": 2,
          "explanation": "Repository 패턴은 데이터 저장소(CSV, DB 등)를 추상화하여 save(), load(), find() 같은 일관된 인터페이스를 제공합니다."
        },
        {
          "question": "pd.concat([df1, df2])의 기본 동작은?",
          "choices": [
            "두 DataFrame을 좌우로 합친다",
            "두 DataFrame을 위아래로 합친다",
            "두 DataFrame의 교집합을 구한다",
            "두 DataFrame의 차집합을 구한다",
            "첫 번째 DataFrame만 반환한다"
          ],
          "answer": 2,
          "explanation": "pd.concat()은 기본적으로 두 DataFrame을 위아래(행 방향)로 합칩니다. axis=1을 지정하면 좌우(열 방향)로 합칠 수 있습니다."
        },
        {
          "question": "os.makedirs('a/b/c', exist_ok=True)에서 exist_ok=True의 역할은?",
          "choices": [
            "폴더를 삭제한다",
            "폴더가 이미 있어도 에러를 발생시키지 않는다",
            "폴더를 숨김 처리한다",
            "폴더 권한을 변경한다",
            "폴더 이름을 변경한다"
          ],
          "answer": 2,
          "explanation": "exist_ok=True를 지정하면 폴더가 이미 존재해도 에러가 발생하지 않습니다. False(기본값)일 경우 FileExistsError가 발생합니다."
        },
        {
          "question": "df[df['age'] > 20]의 결과는?",
          "choices": [
            "age 컬럼만 반환",
            "20보다 큰 숫자 리스트",
            "age가 20보다 큰 행들만 필터링된 DataFrame",
            "True/False 리스트",
            "에러 발생"
          ],
          "answer": 3,
          "explanation": "df[조건]은 조건을 만족하는 행들만 필터링합니다. df[df['age'] > 20]은 age가 20보다 큰 행들만 추출한 DataFrame입니다."
        }
      ]
    },

    "5": {
      "title": "Streamlit UI",
      "guardian": {
        "name": "UI 마법사 스트림릿",
        "greeting": [
          "",
          "✨ 짜잔~! ✨",
          "",
          "환영해! 환영해! 환영한다고~!",
          "",
          "나는 UI 마법사 스트림릿!",
          "세상에서 가장 아름다운 화면을 만드는 마법사지!",
          "",
          "봐봐, st.title! st.button! st.text_input!",
          "이 마법 주문들로 뭐든 만들 수 있어!",
          "",
          "session_state? 그건 마법의 기억 저장소야!",
          "layout? 화면을 예쁘게 나누는 거지!",
          "",
          "자, 네가 UI 마법을 얼마나 이해했는지...",
          "쇼타임 시작이다~! 🎭"
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "브라보~! 🎉 {name}, 완벽해!",
          "",
          "너 UI 마법 진짜 잘 알고 있구나!",
          "st.button도 알고, session_state도 알고!",
          "",
          "이제 네가 만드는 앱은...",
          "세상에서 가장 예쁜 앱이 될 거야!",
          "",
          "다음 관문도 화려하게 통과해!"
        ],
        "failure": [
          "",
          "어머... {name}, 아직이구나.",
          "",
          "UI 마법은 연습이 필요해.",
          "Streamlit 공식 문서 다시 보고 와!",
          "",
          "st.button이랑 session_state 특히 중요해!",
          "다음엔 더 화려하게 돌아와~!"
        ],
        "certificate_message": "세상에서 가장 예쁜 앱을 만들 자격을 얻었습니다!"
      },
      "questions": [
        {
          "question": "st.button('Click')의 반환값은?",
          "choices": [
            "항상 True",
            "항상 False",
            "클릭하면 True, 아니면 False",
            "버튼 객체",
            "None"
          ],
          "answer": 3,
          "explanation": "st.button()은 버튼이 클릭되면 True, 클릭되지 않으면 False를 반환합니다. if st.button('Click'): 으로 클릭 여부를 확인합니다."
        },
        {
          "question": "st.session_state의 주된 용도는?",
          "choices": [
            "파일을 저장한다",
            "페이지 간 상태를 유지한다",
            "데이터베이스에 연결한다",
            "API를 호출한다",
            "로그를 기록한다"
          ],
          "answer": 2,
          "explanation": "st.session_state는 앱 재실행(버튼 클릭 등) 사이에도 상태를 유지할 수 있게 해줍니다. 사용자 입력값, 검색 결과 등을 저장하는 데 사용됩니다."
        },
        {
          "question": "st.text_input('Name')의 반환값은?",
          "choices": [
            "True/False",
            "사용자가 입력한 문자열",
            "텍스트 입력창 객체",
            "None",
            "정수"
          ],
          "answer": 2,
          "explanation": "st.text_input()은 사용자가 입력한 문자열을 반환합니다. 입력이 없으면 빈 문자열('')을 반환합니다."
        },
        {
          "question": "st.columns(2)가 반환하는 것은?",
          "choices": [
            "숫자 2",
            "2개의 컬럼 객체가 담긴 리스트",
            "하나의 컬럼 객체",
            "True/False",
            "None"
          ],
          "answer": 2,
          "explanation": "st.columns(2)는 2개의 컬럼 객체가 담긴 리스트를 반환합니다. col1, col2 = st.columns(2)로 받아서 각각에 내용을 추가합니다."
        },
        {
          "question": "st.sidebar에 위젯을 추가하는 방법으로 올바른 것은?",
          "choices": [
            "st.sidebar.text_input('Name')",
            "st.text_input('Name', sidebar=True)",
            "sidebar(st.text_input('Name'))",
            "st.add_to_sidebar(st.text_input('Name'))",
            "st.text_input('Name').to_sidebar()"
          ],
          "answer": 1,
          "explanation": "st.sidebar.위젯명() 형태로 사이드바에 위젯을 추가합니다. 예: st.sidebar.text_input(), st.sidebar.button() 등"
        },
        {
          "question": "st.success(), st.error(), st.warning()의 공통점은?",
          "choices": [
            "모두 빨간색으로 표시된다",
            "모두 메시지 박스를 표시한다",
            "모두 파일을 저장한다",
            "모두 에러를 발생시킨다",
            "모두 True를 반환한다"
          ],
          "answer": 2,
          "explanation": "세 함수 모두 색깔이 다른 메시지 박스를 표시합니다. success(초록), error(빨강), warning(노랑)으로 상황에 맞게 사용합니다."
        },
        {
          "question": "st.set_page_config()를 호출해야 하는 위치는?",
          "choices": [
            "파일의 맨 마지막",
            "함수 안에서만",
            "다른 st.* 호출보다 먼저",
            "st.title() 바로 뒤",
            "위치는 상관없다"
          ],
          "answer": 3,
          "explanation": "st.set_page_config()는 반드시 다른 모든 st.* 호출보다 먼저 실행되어야 합니다. 보통 main() 함수의 첫 줄에 위치합니다."
        },
        {
          "question": "st.spinner('Loading...')의 용도는?",
          "choices": [
            "에러 메시지를 표시한다",
            "작업 중임을 표시하는 로딩 스피너를 보여준다",
            "페이지를 회전시킨다",
            "버튼을 비활성화한다",
            "파일을 다운로드한다"
          ],
          "answer": 2,
          "explanation": "st.spinner()는 with 문과 함께 사용하여 작업이 진행 중임을 보여주는 로딩 스피너를 표시합니다."
        },
        {
          "question": "st.rerun()의 역할은?",
          "choices": [
            "앱을 종료한다",
            "앱을 처음부터 다시 실행한다",
            "특정 함수만 다시 실행한다",
            "에러를 발생시킨다",
            "파일을 저장한다"
          ],
          "answer": 2,
          "explanation": "st.rerun()은 앱 전체를 처음부터 다시 실행합니다. 상태 변경 후 화면을 즉시 갱신할 때 사용합니다."
        },
        {
          "question": "st.selectbox('Choose', ['A', 'B', 'C'])의 반환값은?",
          "choices": [
            "선택된 항목의 인덱스",
            "선택된 항목의 값",
            "True/False",
            "모든 항목의 리스트",
            "셀렉트박스 객체"
          ],
          "answer": 2,
          "explanation": "st.selectbox()는 사용자가 선택한 항목의 값을 반환합니다. 예에서 'A', 'B', 'C' 중 선택된 값이 반환됩니다."
        }
      ]
    },

    "6": {
      "title": "앱 구조",
      "guardian": {
        "name": "통합 건축가 메인",
        "greeting": [
          "",
          "멈춰라.",
          "",
          "나는 통합 건축가 메인.",
          "모든 코드의 구조를 설계하는 자다.",
          "",
          "if __name__ == \"__main__\"",
          "이 한 줄의 의미를 아는가?",
          "",
          "import 순서, 세션 상태 초기화, 모드 전환...",
          "이 모든 것이 하나로 어우러져야",
          "비로소 완전한 앱이 탄생한다.",
          "",
          "구조가 엉망이면 모든 게 무너진다.",
          "네 건축 실력을 보여라.",
          "2번의 기회, 낭비하지 마라."
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "인정한다, {name}.",
          "",
          "네 코드 구조는 탄탄하다.",
          "진입점을 알고, import를 정리할 줄 알고,",
          "모드 전환의 원리를 이해했다.",
          "",
          "이 인증서를 받아라.",
          "마지막 관문이 기다리고 있다."
        ],
        "failure": [
          "",
          "...부족하다, {name}.",
          "",
          "구조 없이 쌓아올린 코드는",
          "결국 무너지게 되어 있다.",
          "",
          "돌아가서 app.py의 구조를 다시 분석해라.",
          "왜 그렇게 설계되었는지 이해해라."
        ],
        "certificate_message": "탄탄한 코드 구조를 설계할 수 있는 자격을 얻었습니다."
      },
      "questions": [
        {
          "question": "if __name__ == '__main__':의 의미는?",
          "choices": [
            "항상 실행된다",
            "해당 파일이 직접 실행될 때만 아래 코드가 실행된다",
            "다른 파일에서 import될 때만 실행된다",
            "에러가 발생했을 때 실행된다",
            "Python 버전을 확인한다"
          ],
          "answer": 2,
          "explanation": "__name__은 직접 실행 시 '__main__'이 됩니다. import될 때는 모듈 이름이 됩니다. 이를 통해 직접 실행할 때만 main()을 호출할 수 있습니다."
        },
        {
          "question": "import 문의 올바른 순서는?",
          "choices": [
            "외부 → 표준 → 내부",
            "내부 → 외부 → 표준",
            "표준 → 외부 → 내부",
            "알파벳 순",
            "순서는 상관없다"
          ],
          "answer": 3,
          "explanation": "PEP 8 스타일 가이드에 따르면 표준 라이브러리 → 외부 패키지 → 내부 모듈 순서로 import하고, 각 그룹 사이에 빈 줄을 넣습니다."
        },
        {
          "question": "Streamlit에서 모드 전환의 주된 목적은?",
          "choices": [
            "앱을 더 빠르게 만든다",
            "상태에 따라 다른 화면을 보여준다",
            "파일을 저장한다",
            "API를 호출한다",
            "에러를 처리한다"
          ],
          "answer": 2,
          "explanation": "모드 전환을 통해 같은 앱에서 '새 검색' 화면과 '기록 조회' 화면 등 상태에 따라 다른 화면을 보여줄 수 있습니다."
        },
        {
          "question": "st.session_state 초기화 시 if 'key' not in st.session_state:를 사용하는 이유는?",
          "choices": [
            "성능을 높이기 위해",
            "이미 있는 값을 덮어쓰지 않기 위해",
            "에러를 발생시키기 위해",
            "파일을 읽기 위해",
            "API를 호출하기 위해"
          ],
          "answer": 2,
          "explanation": "if not in 체크를 하면 이미 저장된 값(사용자가 변경한 값 등)을 덮어쓰지 않고 유지할 수 있습니다."
        },
        {
          "question": "st.stop()의 역할은?",
          "choices": [
            "앱을 완전히 종료한다",
            "현재 스크립트 실행을 중단한다",
            "버튼을 비활성화한다",
            "파일을 삭제한다",
            "에러를 무시한다"
          ],
          "answer": 2,
          "explanation": "st.stop()은 현재 스크립트 실행을 중단합니다. 에러 발생 시 더 이상 진행하지 않고 멈추게 할 때 사용합니다."
        },
        {
          "question": "Streamlit 앱에서 데이터 흐름의 올바른 순서는?",
          "choices": [
            "저장 → 입력 → 표시",
            "입력 → 처리/저장 → 표시",
            "표시 → 입력 → 저장",
            "처리 → 입력 → 표시",
            "표시 → 저장 → 입력"
          ],
          "answer": 2,
          "explanation": "일반적인 데이터 흐름: 사용자 입력 → 데이터 처리/API 호출/저장 → 결과 화면에 표시 순서로 진행됩니다."
        },
        {
          "question": "다음 중 main() 함수 안에서 가장 먼저 호출해야 하는 것은?",
          "choices": [
            "st.title()",
            "st.write()",
            "st.set_page_config()",
            "st.button()",
            "st.sidebar()"
          ],
          "answer": 3,
          "explanation": "st.set_page_config()는 반드시 다른 모든 Streamlit 함수보다 먼저 호출되어야 합니다."
        },
        {
          "question": "컴포넌트 함수가 값을 반환하는 패턴의 장점은?",
          "choices": [
            "코드가 더 길어진다",
            "호출하는 쪽에서 반환값을 활용할 수 있다",
            "에러가 더 많이 발생한다",
            "실행 속도가 느려진다",
            "메모리를 더 많이 사용한다"
          ],
          "answer": 2,
          "explanation": "render_search_form()이 keyword를 반환하면 main()에서 이를 받아 검색에 활용할 수 있습니다. 컴포넌트 간 데이터 전달이 명확해집니다."
        },
        {
          "question": "SESSION_DEFAULTS 딕셔너리를 사용하는 이유로 가장 적절한 것은?",
          "choices": [
            "성능을 높이기 위해",
            "초기화할 상태를 한 곳에서 관리하기 위해",
            "파일을 저장하기 위해",
            "에러를 방지하기 위해",
            "API를 호출하기 위해"
          ],
          "answer": 2,
          "explanation": "SESSION_DEFAULTS에 초기화할 상태를 모아두면 관리가 쉽고, for문으로 한 번에 초기화할 수 있습니다."
        },
        {
          "question": "st.rerun()을 조건문 없이 사용하면 발생하는 문제는?",
          "choices": [
            "아무 일도 일어나지 않는다",
            "무한 루프가 발생한다",
            "에러 메시지가 표시된다",
            "앱이 더 빨라진다",
            "파일이 삭제된다"
          ],
          "answer": 2,
          "explanation": "st.rerun()이 조건 없이 실행되면 앱이 재실행 → rerun → 재실행 → rerun... 무한 루프에 빠집니다."
        }
      ]
    },

    "7": {
      "title": "에러 핸들링",
      "guardian": {
        "name": "완성의 수호자 독스",
        "greeting": [
          "",
          "어서 오렴, 용감한 여행자여.",
          "",
          "나는 완성의 수호자 독스.",
          "이 던전의 마지막 관문을 지키고 있단다.",
          "",
          "여기까지 왔다는 건...",
          "정말 대단한 일이야.",
          "",
          "마지막 시험은 어렵지 않아.",
          "에러를 다루는 법, 사용자를 배려하는 법,",
          "그리고 문서를 남기는 법...",
          "",
          "이것만 알면 너는 진정한 파이썬 마법사가 될 수 있어.",
          "",
          "자, 마지막 여정을 시작해보자."
        ],
        "start_prompt": "\n[Enter를 눌러 시험을 시작하세요]",
        "success": [
          "",
          "축하한다, {name}!!! 🎊",
          "",
          "드디어 해냈구나!",
          "7개의 모든 관문을 통과하다니...",
          "",
          "너는 이제 진정한 파이썬 마법사야!",
          "",
          "에러를 두려워하지 않고,",
          "사용자를 배려할 줄 알며,",
          "깔끔한 문서를 남기는 개발자...",
          "",
          "네 미래가 빛나길 바라.",
          "이 던전에서 배운 것들이 네 여정에 도움이 되길.",
          "",
          "안녕, 그리고... 축하해."
        ],
        "failure": [
          "",
          "괜찮아, {name}.",
          "",
          "여기까지 온 것만으로도 대단한 거야.",
          "마지막 관문이라 긴장했을 수도 있어.",
          "",
          "에러 핸들링과 UX 부분을 다시 복습해봐.",
          "그리고 다시 도전해.",
          "",
          "난 여기서 기다리고 있을게."
        ],
        "certificate_message": "에러를 두려워하지 않고 사용자를 배려하는 개발자가 되었습니다."
      },
      "questions": [
        {
          "question": "에러 메시지 매핑(ERROR_MESSAGES 딕셔너리)의 장점은?",
          "choices": [
            "코드가 더 길어진다",
            "에러 메시지를 한 곳에서 관리할 수 있다",
            "에러가 더 자주 발생한다",
            "실행 속도가 느려진다",
            "메모리를 더 많이 사용한다"
          ],
          "answer": 2,
          "explanation": "ERROR_MESSAGES 딕셔너리를 사용하면 모든 에러 메시지를 한 곳에서 관리할 수 있고, 수정이나 다국어 지원이 쉬워집니다."
        },
        {
          "question": "빈 상태(Empty State)를 처리하는 이유는?",
          "choices": [
            "에러를 발생시키기 위해",
            "사용자에게 현재 상태와 다음 행동을 안내하기 위해",
            "데이터를 삭제하기 위해",
            "앱을 종료하기 위해",
            "API를 호출하기 위해"
          ],
          "answer": 2,
          "explanation": "빈 화면은 사용자를 혼란스럽게 합니다. '데이터가 없습니다. 검색을 시작해보세요!' 같은 안내를 제공하면 UX가 향상됩니다."
        },
        {
          "question": "Docstring에 포함되어야 하는 정보로 적절하지 않은 것은?",
          "choices": [
            "함수가 하는 일",
            "매개변수 설명",
            "반환값 설명",
            "개발자의 개인 일정",
            "발생 가능한 예외"
          ],
          "answer": 4,
          "explanation": "Docstring에는 함수 설명, 매개변수(Args), 반환값(Returns), 발생 예외(Raises) 등 코드 관련 정보를 작성합니다."
        },
        {
          "question": "타입 힌트 -> None의 의미는?",
          "choices": [
            "함수가 에러를 발생시킨다",
            "함수가 반환값이 없다",
            "함수가 None을 입력받는다",
            "함수가 무한 루프에 빠진다",
            "함수가 파일을 삭제한다"
          ],
          "answer": 2,
          "explanation": "-> None은 함수가 명시적인 반환값이 없음을 나타냅니다. print()처럼 화면에 출력만 하는 함수 등에 사용됩니다."
        },
        {
          "question": "st.spinner()를 사용하는 주된 이유는?",
          "choices": [
            "에러를 표시하기 위해",
            "작업 진행 중임을 사용자에게 알리기 위해",
            "데이터를 저장하기 위해",
            "앱을 종료하기 위해",
            "파일을 읽기 위해"
          ],
          "answer": 2,
          "explanation": "st.spinner()는 시간이 걸리는 작업(API 호출 등) 중에 로딩 스피너를 표시하여 사용자가 앱이 멈춘 게 아님을 알 수 있게 합니다."
        },
        {
          "question": "dict.get(key, default)에서 default의 역할은?",
          "choices": [
            "항상 반환되는 값",
            "key가 없을 때 반환되는 기본값",
            "딕셔너리의 모든 값",
            "에러 메시지",
            "key를 삭제한다"
          ],
          "answer": 2,
          "explanation": "dict.get(key, default)에서 key가 딕셔너리에 없으면 default 값이 반환됩니다. KeyError를 방지할 수 있습니다."
        },
        {
          "question": "README.md에 반드시 포함되어야 하는 내용은?",
          "choices": [
            "개발자의 취미",
            "프로젝트 설치 및 실행 방법",
            "개발자의 좌우명",
            "오늘의 날씨",
            "인기 있는 밈"
          ],
          "answer": 2,
          "explanation": "README.md에는 프로젝트 소개, 설치 방법, 실행 방법, 사용법 등 프로젝트를 시작하는 데 필요한 정보가 포함되어야 합니다."
        },
        {
          "question": "st.toast()와 st.success()의 차이점은?",
          "choices": [
            "색깔이 다르다",
            "toast는 잠시 나타났다 사라지고, success는 계속 표시된다",
            "toast는 에러용이다",
            "success는 사이드바에만 표시된다",
            "차이가 없다"
          ],
          "answer": 2,
          "explanation": "st.toast()는 화면 구석에 잠깐 나타났다 사라지는 알림이고, st.success()는 화면에 계속 남아있는 메시지 박스입니다."
        },
        {
          "question": "handle_error() 함수에서 return을 사용하는 이유는?",
          "choices": [
            "값을 반환하기 위해",
            "에러 발생 후 나머지 코드 실행을 막기 위해",
            "파일을 저장하기 위해",
            "API를 호출하기 위해",
            "앱을 재시작하기 위해"
          ],
          "answer": 2,
          "explanation": "에러 처리 후 return을 하면 함수가 종료되어 나머지 코드가 실행되지 않습니다. 에러 상황에서 잘못된 동작을 방지합니다."
        },
        {
          "question": "사용자 친화적 에러 메시지의 특징으로 적절하지 않은 것은?",
          "choices": [
            "무엇이 잘못되었는지 설명한다",
            "어떻게 해결할 수 있는지 안내한다",
            "기술적인 스택 트레이스를 그대로 보여준다",
            "이모지로 상황을 표현한다",
            "친절한 어조를 사용한다"
          ],
          "answer": 3,
          "explanation": "스택 트레이스는 개발자에게 유용하지만 일반 사용자에게는 혼란을 줍니다. 사용자에게는 '잠시 후 다시 시도해주세요' 같은 친절한 메시지가 좋습니다."
        }
      ]
    }
  }
}
